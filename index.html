<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no, user-scalable=no, viewport-fit=cover">
    <title>Tic-Tac-Toe Advanced</title>
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/vk-bridge.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a1a;
            --primary-color: #2c2c2c;
            --secondary-color: #3f3f3f;
            --accent-color: #00d9ff;
            --text-color: #f0f0f0;
            --x-color: #00d9ff;
            --o-color: #ff007f;
            --border-radius: 12px;
            --transition-speed: 0.3s;
            --board-size: 3;
            --cell-gap: 10px;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; width: 100%; overflow: hidden; }
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 500px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .main-menu, .game-screen { width: 100%; }
        .main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            text-align: center;
        }
        .main-menu.hidden, .game-screen.hidden { display: none; }
        .title {
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 2px;
            background: linear-gradient(90deg, var(--x-color), var(--o-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
        }
        .menu-section {
            background-color: var(--primary-color);
            padding: 20px;
            border-radius: var(--border-radius);
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .menu-section h3 {
            font-size: 1.2rem;
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 10px;
            margin-bottom: 5px;
            font-weight: 600;
        }
        .btn-group { display: flex; gap: 10px; width: 100%; }
        .btn {
            flex-grow: 1; padding: 15px 10px; font-size: 1rem; font-weight: 600;
            background-color: var(--secondary-color); color: var(--text-color);
            border: none; border-radius: 8px; cursor: pointer;
            transition: background-color var(--transition-speed), transform var(--transition-speed);
            border: 2px solid transparent;
        }
        .btn:hover { transform: translateY(-3px); background-color: #4a4a4a; }
        .btn.active { background-color: var(--accent-color); color: var(--bg-color); border-color: var(--accent-color); }
        .start-btn {
            padding: 18px; font-size: 1.2rem; font-weight: 700;
            background: linear-gradient(90deg, var(--x-color), var(--o-color));
            color: var(--text-color); border: none; border-radius: 8px;
            cursor: pointer; transition: transform var(--transition-speed), box-shadow var(--transition-speed);
            margin-top: 10px;
        }
        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.5), 0 0 20px rgba(255, 0, 127, 0.5);
        }
        #stats-display { font-size: 0.9rem; color: #aaa; margin-top: 10px; }
        .game-screen { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        .game-header { width: 100%; display: flex; justify-content: space-between; align-items: center; }
        #status-text { font-size: 1.5rem; font-weight: 600; }
        #pause-btn { background: none; border: none; color: var(--text-color); font-size: 1.8rem; cursor: pointer; transition: color var(--transition-speed); }
        #pause-btn:hover { color: var(--accent-color); }
        #board {
            display: grid; grid-template-columns: repeat(var(--board-size), 1fr);
            gap: var(--cell-gap); width: 100%; background-color: var(--primary-color);
            padding: var(--cell-gap); border-radius: var(--border-radius);
        }
        .cell {
            aspect-ratio: 1 / 1; background-color: var(--secondary-color);
            border-radius: 8px; display: flex; justify-content: center;
            align-items: center; cursor: pointer; transition: background-color var(--transition-speed);
        }
        .cell:not(.x):not(.o):hover { background-color: #4a4a4a; }
        .cell.x, .cell.o {
            cursor: not-allowed; font-size: min(10vw, calc(300px / var(--board-size) * 0.7));
            font-weight: 700; line-height: 1;
        }
        .cell.x { color: var(--x-color); }
        .cell.o { color: var(--o-color); }
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(26, 26, 26, 0.8); backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity var(--transition-speed);
            z-index: 1000;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        .overlay-content {
            background-color: var(--primary-color); padding: 40px; border-radius: var(--border-radius);
            text-align: center; display: flex; flex-direction: column; gap: 20px;
            transform: scale(0.9); transition: transform var(--transition-speed);
        }
        .overlay.active .overlay-content { transform: scale(1); }
        .overlay-content h2 { font-size: 2rem; margin-bottom: 10px; }
        .overlay-content .btn-group { flex-direction: column; }
        @media (max-width: 500px) {
            :root { --cell-gap: 5px; }
            .title { font-size: 2rem; }
            #status-text { font-size: 1.2rem; }
            .btn { padding: 12px 8px; font-size: 0.9rem;}
            .start-btn { padding: 15px; font-size: 1.1rem; }
            .overlay-content { padding: 30px; width: calc(100% - 40px); }
            .overlay-content h2 { font-size: 1.8rem; }
        }
    </style>
</head>
<body>

    <div class="container">
        <div id="main-menu" class="main-menu">
            <h1 class="title">TIC-TAC-TOE</h1>
            <div class="menu-section">
                <h3>Размер Поля</h3>
                <div class="btn-group" id="board-size-selector">
                    <button class="btn active" data-size="3">3x3 (3 в ряд)</button>
                    <button class="btn" data-size="4">4x4 (4 в ряд)</button>
                    <button class="btn" data-size="5">5x5 (4 в ряд)</button>
                </div>
            </div>
            <div class="menu-section">
                <h3>Режим Игры</h3>
                <div class="btn-group" id="game-mode-selector">
                    <button class="btn active" data-mode="pvc">VS Компьютер</button>
                    <button class="btn" data-mode="pvp">VS Игрок</button>
                </div>
            </div>
            <button id="start-game-btn" class="start-btn">Начать Игру</button>
            <div id="stats-display">Загрузка статистики...</div>
        </div>
        <div id="game-screen" class="game-screen hidden">
            <div class="game-header">
                <div id="status-text">Ход X</div>
                <button id="pause-btn">❚❚</button>
            </div>
            <div id="board"></div>
        </div>
    </div>
    <div id="pause-overlay" class="overlay">
        <div class="overlay-content">
            <h2>Пауза</h2>
            <div class="btn-group">
                <button id="resume-btn" class="btn">Продолжить</button>
                <button id="restart-pause-btn" class="btn">Начать заново</button>
                <button id="menu-pause-btn" class="btn">Главное меню</button>
            </div>
        </div>
    </div>
    <div id="game-over-overlay" class="overlay">
        <div class="overlay-content">
            <h2 id="game-over-message"></h2>
            <div class="btn-group">
                <button id="restart-game-over-btn" class="btn">Играть снова</button>
                <button id="menu-game-over-btn" class="btn">Главное меню</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // === DOM Elements and State ===
            const mainMenu = document.getElementById('main-menu'), gameScreen = document.getElementById('game-screen'),
                  boardElement = document.getElementById('board'), statusText = document.getElementById('status-text'),
                  pauseBtn = document.getElementById('pause-btn'), pauseOverlay = document.getElementById('pause-overlay'),
                  gameOverOverlay = document.getElementById('game-over-overlay'), statsDisplay = document.getElementById('stats-display');

            let boardSize = 3, gameMode = 'pvc', currentPlayer = 'X', boardState = [],
                isGameOver = false, isPaused = false, humanPlayer = 'X', aiPlayer = 'O',
                stats = { wins: 0, losses: 0, ties: 0, gamesPlayedSinceAd: 0 };
            const STATS_KEY = 'ticTacToeUserStats_v2'; 

            // === VK Integration ===
            async function initApp() {
                try {
                    await vkBridge.send('VKWebAppInit');
                    await loadStats();
                    vkBridge.send('VKWebAppShowBannerAd', {
                        banner_location: 'bottom'
                    }).catch(e => console.error("Banner ad error", e));
                } catch (error) {
                    console.error('VK App Init Error:', error);
                    updateStatsDisplay();
                }
            }
            async function saveStats() {
                try {
                    await vkBridge.send('VKWebAppStorageSet', {
                        key: STATS_KEY, value: JSON.stringify(stats)
                    });
                } catch (error) { console.error('VK Storage Save Error:', error); }
            }
            async function loadStats() {
                try {
                    const data = await vkBridge.send('VKWebAppStorageGet', { keys: [STATS_KEY] });
                    if (data.keys[0].value) {
                        const loadedStats = JSON.parse(data.keys[0].value);
                        if(loadedStats.wins !== undefined && loadedStats.gamesPlayedSinceAd !== undefined) {
                            stats = loadedStats;
                        }
                    }
                } catch (error) { console.error('VK Storage Load Error:', error); }
                updateStatsDisplay();
            }

            // === Event Listeners ===
            document.getElementById('board-size-selector').addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    handleSelector(e.target, '#board-size-selector');
                    boardSize = parseInt(e.target.dataset.size);
                }
            });
            document.getElementById('game-mode-selector').addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    handleSelector(e.target, '#game-mode-selector');
                    gameMode = e.target.dataset.mode;
                }
            });
            document.getElementById('start-game-btn').addEventListener('click', startGame);
            pauseBtn.addEventListener('click', togglePause);
            document.getElementById('resume-btn').addEventListener('click', togglePause);
            document.getElementById('restart-pause-btn').addEventListener('click', () => { togglePause(); startGame(); });
            document.getElementById('menu-pause-btn').addEventListener('click', () => { togglePause(); showMainMenu(); });
            document.getElementById('restart-game-over-btn').addEventListener('click', () => { hideOverlay(gameOverOverlay); startGame(); });
            document.getElementById('menu-game-over-btn').addEventListener('click', () => { hideOverlay(gameOverOverlay); showMainMenu(); });

            // === Core Game Functions ===
            function handleSelector(target, parentSelector) {
                document.querySelectorAll(`${parentSelector} button`).forEach(btn => btn.classList.remove('active'));
                target.classList.add('active');
            }
            function getWinLength() {
                return boardSize === 3 ? 3 : 4;
            }
            function startGame() {
                isGameOver = false; currentPlayer = 'X';
                boardState = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
                boardElement.innerHTML = '';
                boardElement.style.setProperty('--board-size', boardSize);
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = i; cell.dataset.col = j;
                        cell.addEventListener('click', handleCellClick);
                        boardElement.appendChild(cell);
                    }
                }
                statusText.textContent = `Ход ${currentPlayer}`;
                mainMenu.classList.add('hidden'); gameScreen.classList.remove('hidden');
                if (gameMode === 'pvc' && currentPlayer !== humanPlayer) {
                    setTimeout(aiMove, 500);
                }
            }
            function handleCellClick(e) {
                if (isGameOver || isPaused) return;
                const cell = e.target;
                const row = cell.dataset.row; const col = cell.dataset.col;
                if (boardState[row][col] || (gameMode === 'pvc' && currentPlayer === aiPlayer)) return;
                makeMove(row, col, currentPlayer);
                if (checkWin(currentPlayer)) {
                    endGame(false);
                } else if (isBoardFull()) {
                    endGame(true);
                } else {
                    switchPlayer();
                    if (gameMode === 'pvc' && currentPlayer === aiPlayer) {
                        setTimeout(aiMove, 500);
                    }
                }
            }
            function makeMove(row, col, player) {
                boardState[row][col] = player;
                const cell = document.querySelector(`[data-row='${row}'][data-col='${col}']`);
                cell.textContent = player; cell.classList.add(player.toLowerCase());
            }
            function switchPlayer() {
                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                statusText.textContent = `Ход ${currentPlayer}`;
            }
            
            // ИСПРАВЛЕНА: Проверка победы для любого размера поля и условия
            function checkWin(player) {
                const winLength = getWinLength();
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        if (c <= boardSize - winLength) { // Horizontal
                            let line = true;
                            for (let i = 0; i < winLength; i++) if (boardState[r][c+i] !== player) line = false;
                            if(line) return true;
                        }
                        if (r <= boardSize - winLength) { // Vertical
                            let line = true;
                            for (let i = 0; i < winLength; i++) if (boardState[r+i][c] !== player) line = false;
                            if(line) return true;
                        }
                        if (r <= boardSize - winLength && c <= boardSize - winLength) { // Diagonal \
                            let line = true;
                            for (let i = 0; i < winLength; i++) if (boardState[r+i][c+i] !== player) line = false;
                            if(line) return true;
                        }
                        if (r <= boardSize - winLength && c >= winLength - 1) { // Diagonal /
                            let line = true;
                            for (let i = 0; i < winLength; i++) if (boardState[r+i][c-i] !== player) line = false;
                            if(line) return true;
                        }
                    }
                }
                return false;
            }

            function isBoardFull() { return boardState.flat().every(cell => cell !== null); }
            
            async function endGame(isDraw) {
                isGameOver = true;
                const message = isDraw ? "Ничья!" : `Победил ${currentPlayer}!`;
                document.getElementById('game-over-message').textContent = message;
                showOverlay(gameOverOverlay);
                if (gameMode === 'pvc') {
                    if (isDraw) stats.ties++;
                    else if (currentPlayer === humanPlayer) stats.wins++;
                    else stats.losses++;
                }
                stats.gamesPlayedSinceAd = (stats.gamesPlayedSinceAd || 0) + 1;
                await saveStats();
                updateStatsDisplay();
                if (stats.gamesPlayedSinceAd >= 3) {
                    try {
                        const adResult = await vkBridge.send('VKWebAppShowNativeAds', { ad_format: 'interstitial' });
                        if(adResult.result) {
                            stats.gamesPlayedSinceAd = 0;
                            await saveStats();
                        }
                    } catch (error) { console.error('Interstitial Ad Error:', error); }
                }
            }
            function togglePause() { isPaused = !isPaused; isPaused ? showOverlay(pauseOverlay) : hideOverlay(pauseOverlay); }
            function showOverlay(overlay) { overlay.classList.add('active'); }
            function hideOverlay(overlay) { overlay.classList.remove('active'); }
            function showMainMenu() {
                gameScreen.classList.add('hidden'); mainMenu.classList.remove('hidden');
                updateStatsDisplay();
            }
            function updateStatsDisplay() {
                if(stats) statsDisplay.textContent = `Статистика (VS ИИ): Побед: ${stats.wins} | Поражений: ${stats.losses} | Ничьи: ${stats.ties}`;
            }

            // === AI LOGIC ===
            function getMovesMade() {
                return boardState.flat().filter(Boolean).length;
            }

            // ИСПРАВЛЕНА: Логика выбора хода
            function findBestMove() {
                // ИСПРАВЛЕНИЕ: Первый ход ИИ в 3x3 всегда случайный
                if (boardSize === 3 && getMovesMade() <= 1) {
                    const emptyCells = [];
                    for(let i=0; i<boardSize; i++) for(let j=0; j<boardSize; j++) if(!boardState[i][j]) emptyCells.push({row: i, col: j});
                    return emptyCells[Math.floor(Math.random() * emptyCells.length)];
                }
                
                let bestVal = -Infinity;
                let bestMoves = [];
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (boardState[i][j] === null) {
                            boardState[i][j] = aiPlayer;
                            let moveVal = minimax(0, false, -Infinity, Infinity);
                            boardState[i][j] = null;
                            if (moveVal > bestVal) {
                                bestVal = moveVal;
                                bestMoves = [{ row: i, col: j }];
                            } else if (moveVal === bestVal) {
                                bestMoves.push({ row: i, col: j });
                            }
                        }
                    }
                }
                if (bestMoves.length > 0) {
                    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
                }
                return null;
            }
            
            function aiMove() {
                if (isGameOver) return;
                statusText.textContent = `Думает ${aiPlayer}...`;
                requestAnimationFrame(() => {
                    const bestMove = findBestMove();
                    if (bestMove) {
                        makeMove(bestMove.row, bestMove.col, aiPlayer);
                        if (checkWin(aiPlayer)) { endGame(false); } 
                        else if (isBoardFull()) { endGame(true); } 
                        else { switchPlayer(); }
                    } else {
                         console.error("AI couldn't find a move."); // Если ходов нет
                    }
                });
            }
            
            // ИСПРАВЛЕНА: Основная функция минимакса с умной оценкой
            function minimax(depth, isMaximizing, alpha, beta) {
                if (checkWin(aiPlayer)) return 100000 - depth;
                if (checkWin(humanPlayer)) return -100000 + depth;
                if (isBoardFull()) return 0;
                if (depth >= getSearchDepth()) return evaluateBoard();

                let bestVal = isMaximizing ? -Infinity : Infinity;
                const player = isMaximizing ? aiPlayer : humanPlayer;

                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (boardState[i][j] === null) {
                            boardState[i][j] = player;
                            const score = minimax(depth + 1, !isMaximizing, alpha, beta);
                            boardState[i][j] = null;
                            
                            if (isMaximizing) {
                                bestVal = Math.max(bestVal, score);
                                alpha = Math.max(alpha, bestVal);
                            } else {
                                bestVal = Math.min(bestVal, score);
                                beta = Math.min(beta, bestVal);
                            }
                            if (beta <= alpha) return bestVal;
                        }
                    }
                }
                return bestVal;
            }
            
            function getSearchDepth() {
                if (boardSize === 3) return 9;
                if (boardSize === 4) return 4;
                return 3; 
            }
            
            // УЛУЧШЕНА: Функция оценки для больших полей
            function evaluateBoard() {
                if (boardSize === 3) return 0; // Для 3х3 не нужна, минимакс и так все просчитает
                let totalScore = 0;
                const winLength = getWinLength();

                const evaluateWindow = (window) => {
                    let score = 0;
                    const aiCount = window.filter(p => p === aiPlayer).length;
                    const humanCount = window.filter(p => p === humanPlayer).length;

                    if (aiCount > 0 && humanCount > 0) return 0; // Блокированная линия
                    if (aiCount > 0) {
                        if (aiCount === winLength - 1) score += 5000;
                        else if (aiCount === winLength - 2) score += 100;
                        else score += 10;
                    } else if (humanCount > 0) {
                        if (humanCount === winLength - 1) score -= 10000; // Блокировка важнее
                        else if (humanCount === winLength - 2) score -= 500;
                        else score -= 20;
                    }
                    return score;
                };

                // Проверяем все возможные "окна" нужной длины
                for (let r = 0; r < boardSize; r++) {
                    for (let c = 0; c < boardSize; c++) {
                        if (c <= boardSize - winLength) { // Горизонтали
                            totalScore += evaluateWindow(boardState[r].slice(c, c + winLength));
                        }
                        if (r <= boardSize - winLength) { // Вертикали
                            let window = [];
                            for(let i=0; i<winLength; i++) window.push(boardState[r+i][c]);
                            totalScore += evaluateWindow(window);
                        }
                        if (r <= boardSize - winLength && c <= boardSize - winLength) { // Диагонали \
                            let window = [];
                            for(let i=0; i<winLength; i++) window.push(boardState[r+i][c+i]);
                            totalScore += evaluateWindow(window);
                        }
                        if (r <= boardSize - winLength && c >= winLength - 1) { // Диагонали /
                            let window = [];
                            for(let i=0; i<winLength; i++) window.push(boardState[r+i][c-i]);
                            totalScore += evaluateWindow(window);
                        }
                    }
                }
                return totalScore;
            }

            // === Initial Load ===
            initApp();
        });
    </script>
</body>
</html>
